// ------------  Paquete e importaciones ------------
package interprete;

import java_cup.runtime.*;
import expresiones.Dato;
import expresiones.Aritmeticas;
import expresiones.TipoDato;
import java.util.ArrayList;
import java.util.LinkedList;
import instruccion.Instruccion;
import funciones.Println;
import expresiones.Expresion;
import expresiones.Negativo;
import expresiones.Relacionales;
import expresiones.Logicos;
import funciones.DecVariables;

//------> Codigo para el parser
//------> Declaracion de variables, funciones y funciones de error

parser code 
{:

        //instancias de las clases


        //arreglo para las instrucciones

    public String resultado = ""; 

    public void syntax_error(Symbol s)
    {
            System.err.println("Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Recuperado" );
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
            System.err.println("Error Sintactico: "+ s.value + " - Fila: " + s.right + " - Columna: " + s.left + ". Sin recuperacion." );
    }

:}


//------> Codigo para las acciones gramaticales (no tocar)
action code
{:  :}


//------> Declaración de terminales

//tipos de datos
terminal String INT, DOUBLE, BOOL, CHAR, STRING;

//simbolos
terminal String PYC, DOS_P, MAS, MENOS, POR, DIVIDIR, MODULO, IGUALACION, DIFERENCIACION, MENOR_IGUAL, MAYOR_IGUAL, IGUAL, NOT, MENOR_Q, MAYOR_Q;
terminal String OR, AND, XOR, A_PARENTESIS, C_PARENTESIS, A_LLAVE, C_LLAVE, A_CORCHETE, C_CORCHETE, COMA, PUNTO;
terminal String POTENCIA;

//reservadas
terminal String CONSTANTE, VARIABLE, IF, ELSE, MATCH, DEFAULT, WHILE, FOR, DO, BREAK, CONTINUE, RETURN;
terminal String LIST, NEW, APPEND, REMOVE, STRUCT, VOID;

//funciones
terminal String PRINTLN, ROUND, LENGTH, TOSTRING, FIND, START_WITH;

//expresiones
terminal String ENTERO, DECIMAL, BOOLEANO, CADENA, CARACTER, ID;


terminal String UMENOS;


//------> Declaración de no terminales
non terminal LinkedList<Instruccion> inicio;
non terminal LinkedList<Instruccion> instruccion;
non terminal Instruccion expresiones;
non terminal tipoExpresion;
non terminal Instruccion declararVariables;
non terminal asignarVariables;
non terminal accVariables;
non terminal casteos;
non terminal incDec;
non terminal sentIF;
non terminal elseIF;
non terminal sentWhile;
non terminal sentFOR;
non terminal Instruccion printConsole;
non terminal Expresion expresion;


//-------> Precedencias

precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NOT;
precedence left IGUALACION, DIFERENCIACION, MENOR_Q, MENOR_IGUAL, MAYOR_Q, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left POR, DIVIDIR, MODULO;
precedence nonassoc POTENCIA;
precedence right UMENOS;


//------> Definir Simbolo Inicial
start with inicio; 

// ------------>  Producciones  <------------

inicio ::= instruccion:val {: RESULT=val; :}
;

instruccion ::= expresiones:a                     {:RESULT = new LinkedList<>(); RESULT.add(a);:}
                | instruccion:a expresiones:b       {:RESULT = a; RESULT.add(b);:}
;

expresiones ::= printConsole:a    {:RESULT=a;:}
;


//Tipos de datos
tipoExpresion ::= INT:val     {:RESULT=val;:}
        | DOUBLE:val          {:RESULT=val;:}
        | BOOL:val            {:RESULT=val;:}
        | CHAR:val            {:RESULT=val;:}
        | STRING:val          {:RESULT=val;:}

;


//Declarar variables
declararVariables ::= VARIABLE:mut ID:id DOS_P tipoExpresion:tipo PYC //{:RESULT=new DecVariables(mut, id, tipo, null, tipoleft, tiporight);:}
                | CONSTANTE:mut ID:id DOS_P tipoExpresion:tipo PYC //{:RESULT=new DecVariables(mut, id, tipo, null, tipoleft, tiporight);:}
                | VARIABLE:mut ID:id DOS_P tipoExpresion:tipo IGUAL expresion:exp PYC //{:RESULT=new DecVariables(mut, id.toLowerCase(), TipoDato.tipo, exp, expleft, expright);:}
                | CONSTANTE:mut ID:id DOS_P tipoExpresion:tipo IGUAL expresion:exp PYC //{:RESULT=new DecVariables(mut, id.toLowerCase(), TipoDato.tipo, exp, expleft, expright);:}
;


//asignar variables
asignarVariables ::= ID IGUAL expresion PYC
;


//Acc a variables
accVariables ::= ID
;


//Casteos
casteos ::= VARIABLE ID DOS_P tipoExpresion IGUAL A_PARENTESIS tipoExpresion C_PARENTESIS expresion PYC
        | CONSTANTE ID DOS_P tipoExpresion IGUAL A_PARENTESIS tipoExpresion C_PARENTESIS expresion PYC
;


//Incremento-Decremento
incDec ::= ID MAS MAS PYC
        | ID MENOS MENOS PYC
;


//Sentencia de control

        //Sentencia if
sentIF ::= IF A_PARENTESIS expresion C_PARENTESIS A_LLAVE instruccion C_LLAVE 
        | IF A_PARENTESIS expresion C_PARENTESIS A_LLAVE instruccion C_LLAVE elseIF
;

elseIF ::= ELSE A_LLAVE instruccion C_LLAVE
        | ELSE sentIF
;

        //Sentencia MATCH
//sentMATCH ::=
//;


//Sentencia ciclicas

        //while
sentWhile ::= A_PARENTESIS expresion C_PARENTESIS A_LLAVE instruccion C_LLAVE
;

        //FOR
sentFOR ::= FOR A_PARENTESIS 
;

        // DO-WHILE
//sentDO ::= 
//;

//sentencias de transferencia

        //beak


        //continue



//imprimir en consola
printConsole ::= PRINTLN A_PARENTESIS expresion:val C_PARENTESIS PYC {:RESULT= new Println(val, valleft, valright);:}
;


//expresiones 
expresion::= MENOS expresion: val                       {:RESULT = new Negativo(val, valleft, valright);:}%prec UMENOS
        | expresion:val1 POTENCIA  expresion:val2       {:RESULT = new Aritmeticas(val1, "**", val2, val2left,val2right);:}
        | expresion:val1 POR expresion:val2             {:RESULT = new Aritmeticas(val1, "*", val2, val2left,val2right);:}
        | expresion:val1 DIVIDIR expresion:val2         {:RESULT = new Aritmeticas(val1, "/", val2, val2left,val2right);:}
        | expresion:val1 MODULO expresion:val2          {:RESULT = new Aritmeticas(val1, "%", val2, val2left,val2right);:}
        | expresion:val1 MAS expresion:val2             {:RESULT = new Aritmeticas(val1, "+", val2, val2left,val2right);:}
        | expresion:val1 MENOS expresion:val2           {:RESULT = new Aritmeticas(val1, "-", val2, val2left,val2right);:}
        | expresion:val1 IGUALACION expresion:val2      {:RESULT = new Relacionales(val1, val2, "==", val2left, val2right);:}
        | expresion:val1 DIFERENCIACION expresion:val2  {:RESULT = new Relacionales(val1, val2, "!=", val2left, val2right);:}
        | expresion:val1 MENOR_Q expresion:val2         {:RESULT = new Relacionales(val1, val2, "<", val2left, val2right);:}
        | expresion:val1 MENOR_IGUAL expresion:val2     {:RESULT = new Relacionales(val1, val2, "<=", val2left, val2right);:}
        | expresion:val1 MAYOR_Q expresion:val2         {:RESULT = new Relacionales(val1, val2, ">", val2left, val2right);:}
        | expresion:val1 MAYOR_IGUAL expresion:val2     {:RESULT = new Relacionales(val1, val2, ">=", val2left, val2right);:}
        | NOT expresion :val                            {:RESULT = new Logicos(val, val, "!", valleft, valright);:}%prec NOT
        | expresion:val1 XOR expresion:val2             {:RESULT = new Logicos(val1, val2, "^", val2left, val2right);:}
        | expresion:val1 OR expresion:val2              {:RESULT = new Logicos(val1, val2, "||", val2left, val2right);:}
        | expresion:val1 AND expresion:val2             {:RESULT = new Logicos(val1, val2, "&&", val2left, val2right);:}
        | A_PARENTESIS expresion:val C_PARENTESIS       {:RESULT = val;:}
        | ENTERO:val                                    {:RESULT = new Dato(val, TipoDato.INT, valleft, valright);:}
        | DECIMAL:val                                   {: RESULT = new Dato(val, TipoDato.DOUBLE, valleft, valright);:} 
        | BOOLEANO:val                                  {: RESULT = new Dato(val, TipoDato.BOOLEAN, valleft, valright);:}
        | CADENA:val                                    {: RESULT = new Dato(val, TipoDato.CADENA, valleft, valright);:}
        | CARACTER:val                                  {: RESULT = new Dato(val, TipoDato.CHAR, valleft, valright);:}
;
